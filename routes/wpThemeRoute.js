// routes/wpThemeRoute.js
const fs = require('fs');
const path = require('path');
const express = require('express');
const archiver = require('archiver');
const { getBuildRecord } = require('../utils/buildRegistry');

const router = express.Router();

router.post('/export-wp', express.urlencoded({ extended: false }), async (req, res) => {
  try {
    const buildId = (req.body.buildId || '').trim();
    const rec = getBuildRecord(buildId);
    if (!rec) return res.status(400).send('Unknown or expired build.');

    const src = rec.outputDir; // your already generated static site folder

    // derive theme name/slug from meta or folder
    const biz = (rec.meta?.businessName || 'Site').toString();
    const loc = (rec.meta?.location || '').toString();
    const themeName = `${biz}${loc ? ' ' + loc : ''}`.trim();
    const themeSlug = themeName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') || 'wp-theme';

    // create theme skeleton in /dist
    const distDir = path.resolve('dist');
    const themeDir = path.join(distDir, `${themeSlug}-theme`);
    const assetsDir = path.join(themeDir, 'assets');
    const cssDir = path.join(assetsDir, 'css');     // kept for possible fallbacks
    const imgDir = path.join(assetsDir, 'img');     // kept (we now preserve paths below)
    const incDir = path.join(themeDir, 'inc');
    const acfJsonDir = path.join(themeDir, 'acf-json');

    fs.rmSync(themeDir, { recursive: true, force: true });
    [themeDir, assetsDir, cssDir, imgDir, incDir, acfJsonDir].forEach(d => fs.mkdirSync(d, { recursive: true }));

    // --- Required WP files ---
    fs.writeFileSync(path.join(themeDir, 'style.css'), `/*
Theme Name: ${themeName}
Author: Generated by Your App
Version: 1.0.0
Text Domain: ${themeSlug}
*/`);

    fs.writeFileSync(path.join(incDir, 'helpers.php'), `<?php
function site_settings_id() {
  static $id = null;
  if ($id !== null) return $id;
  $p = get_page_by_path('site-settings') ?: get_page_by_title('Site Settings');
  $id = $p ? $p->ID : 0; return $id;
}
function ssf($field){ $id = site_settings_id(); return ($id && function_exists('get_field')) ? get_field($field, $id) : null; }
function field($name, $post_id=null){ if(!function_exists('get_field')) return ''; return get_field($name, $post_id?:get_the_ID()); }`);

    fs.writeFileSync(path.join(themeDir, 'header.php'), `<?php ?><!doctype html>
<html <?php language_attributes(); ?>>
<head><meta charset="<?php bloginfo('charset'); ?>">
<meta name="viewport" content="width=device-width,initial-scale=1"><?php wp_head(); ?>
</head><body <?php body_class(); ?>>
<header class="site-header"><div class="container">
<a class="site-logo" href="<?php echo esc_url(home_url('/')); ?>"><?php bloginfo('name'); ?></a>
<nav><?php wp_nav_menu(['theme_location'=>'primary','container'=>false,'fallback_cb'=>false]); ?></nav>
</div></header><main class="site-main">`);

    fs.writeFileSync(path.join(themeDir, 'footer.php'), `</main>
<footer class="site-footer"><div class="container">&copy; <?php echo date('Y'); ?> <?php bloginfo('name'); ?></div></footer>
<?php wp_footer(); ?></body></html>`);

    // index.php fallback
    fs.writeFileSync(path.join(themeDir, 'index.php'), `<?php get_header(); ?>
<?php if (have_posts()) : while (have_posts()) : the_post(); ?>
<article <?php post_class(); ?>><h1><?php the_title(); ?></h1><div class="entry-content"><?php the_content(); ?></div></article>
<?php endwhile; else: ?><h2>No content found</h2><?php endif; ?>
<?php get_footer(); ?>`);

    // --- Pick the built HTML file(s) we’ll scan for CSS and wrap into front-page.php ---
    const htmlCandidates = [
      path.join(src, 'index.html'),
      path.join(src, 'about-us.html'), // fallback if you use about as landing
    ].filter(fs.existsSync);

    // ===================== CSS DISCOVERY + COPYING =====================
    // 0) Read the built HTML (we’ll use the first match)
    const rawHtml = htmlCandidates[0] ? fs.readFileSync(htmlCandidates[0], 'utf8') : '';
    const headMatch = rawHtml.match(/<head[^>]*>([\s\S]*?)<\/head>/i);
    const headHtml  = headMatch ? headMatch[1] : '';

    // 1) Find all <link rel="stylesheet" href="..."> in order
    const cssHrefs = [];
    for (const m of headHtml.matchAll(/<link[^>]+rel=["']?stylesheet["']?[^>]*href=["']([^"']+)["'][^>]*>/gi)) {
      cssHrefs.push(m[1]);
    }

    // 2) Normalize, copy locals preserving the SAME paths, and build enqueue list
    const seen = new Set();
    const stylesForEnqueue = [];

    const normalizeHref = (href) => {
      const noHash  = href.split('#')[0];
      const noQuery = noHash.split('?')[0];
      return noQuery;
    };

    const copyLocalCss = (href) => {
      let rel = normalizeHref(href).replace(/^[\/]+/, '').replace(/^\.\//, '');

      // Avoid colliding with theme root style.css (header file).
      // Keep it at the ROOT to preserve relative urls, but rename to style.static.css
      if (rel.toLowerCase() === 'style.css') rel = 'style.static.css';

      const srcPath = path.join(src, rel);
      if (fs.existsSync(srcPath)) {
        const destPath = path.join(themeDir, rel);
        fs.mkdirSync(path.dirname(destPath), { recursive: true });
        fs.copyFileSync(srcPath, destPath);
        stylesForEnqueue.push({ handle: `${themeSlug}-${stylesForEnqueue.length}`, url: rel, external: false });
        return true;
      }
      return false;
    };

    for (const href of cssHrefs) {
      if (seen.has(href)) continue;
      seen.add(href);

      if (/^https?:\/\//i.test(href)) {
        // external (CDN)
        stylesForEnqueue.push({ handle: `${themeSlug}-${stylesForEnqueue.length}`, url: href, external: true });
      } else {
        copyLocalCss(href);
      }
    }

    // 3) Directory fallback: copy common css dirs wholesale if nothing found
    if (stylesForEnqueue.length === 0) {
      const candidateDirs = ['css', path.join('assets','css'), 'styles', path.join('assets','styles')];
      for (const relDir of candidateDirs) {
        const abs = path.join(src, relDir);
        if (fs.existsSync(abs)) {
          const dest = path.join(themeDir, relDir);
          fs.mkdirSync(dest, { recursive: true });
          fs.cpSync(abs, dest, { recursive: true });
          const files = fs.readdirSync(dest, { withFileTypes: true })
            .filter(d => d.isFile() && /\.css$/i.test(d.name))
            .map(d => path.join(relDir, d.name));
          files.forEach(f => stylesForEnqueue.push({ handle: `${themeSlug}-${stylesForEnqueue.length}`, url: f, external: false }));
        }
      }
    }

    // 4) Absolute last resort: create a tiny file so the theme has something
    if (stylesForEnqueue.length === 0) {
      const fallback = path.join(themeDir, 'assets/css/site.css');
      fs.mkdirSync(path.dirname(fallback), { recursive: true });
      const maybe = path.join(src, 'css', 'style.css');
      if (fs.existsSync(maybe)) fs.copyFileSync(maybe, fallback);
      else fs.writeFileSync(fallback, '/* no css found */');
      stylesForEnqueue.push({ handle: `${themeSlug}-site`, url: 'assets/css/site.css', external: false });
    }

    // 5) Build enqueue code for ALL styles, respecting order
    const enqueueLines = stylesForEnqueue.map(s =>
      s.external
        ? `wp_enqueue_style('${s.handle}', '${s.url}', [], null);`
        : `wp_enqueue_style('${s.handle}', get_template_directory_uri() . '/${s.url}', [], '1.0');`
    ).join('\n  ');

    // --- NOW write functions.php using the generated enqueueLines ---
    fs.writeFileSync(path.join(themeDir, 'functions.php'), `<?php
add_action('after_setup_theme', function () {
  add_theme_support('title-tag');
  add_theme_support('post-thumbnails');
  add_theme_support('html5', ['search-form','gallery','caption','style','script']);
  register_nav_menus(['primary' => __('Primary Menu', '${themeSlug}')]);
});

add_action('wp_enqueue_scripts', function () {
  ${enqueueLines}
});

add_filter('acf/settings/load_json', function($paths){ $paths[] = get_stylesheet_directory() . '/acf-json'; return $paths; });

add_action('admin_notices', function () {
  if (current_user_can('install_plugins') && !function_exists('get_field')) {
    $url = admin_url('plugin-install.php?s=Advanced%20Custom%20Fields&tab=search&type=term');
    echo '<div class="notice notice-warning"><p><strong>This theme requires Advanced Custom Fields (free).</strong> Please <a href="'.esc_url($url).'">install & activate ACF</a>.</p></div>';
  }
});

require_once __DIR__ . '/inc/helpers.php';
`);

    // ===================== IMAGES / FONTS (preserve paths) =====================
    ['img', 'images', path.join('assets','img'), path.join('assets','images')].forEach(rel => {
      const from = path.join(src, rel);
      if (fs.existsSync(from)) {
        const to = path.join(themeDir, rel);
        fs.mkdirSync(path.dirname(to), { recursive: true });
        fs.cpSync(from, to, { recursive: true });
      }
    });
    ['fonts', path.join('assets','fonts')].forEach(rel => {
      const from = path.join(src, rel);
      if (fs.existsSync(from)) {
        const to = path.join(themeDir, rel);
        fs.mkdirSync(path.dirname(to), { recursive: true });
        fs.cpSync(from, to, { recursive: true });
      }
    });

    // --- Build a front-page.php from your already-generated index.html ---
    let frontContent = '<section class="hero"><h1><?php echo esc_html(field(\'hero_h1\')); ?></h1><p><?php echo esc_html(field(\'hero_tagline\')); ?></p></section>';
    if (htmlCandidates[0]) {
      // naive wrap: put your static HTML between header/footer (best-effort)
      const raw = fs.readFileSync(htmlCandidates[0], 'utf8');
      // strip full html/head/body if present, keep inside <body>…</body>
      const bodyMatch = raw.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      frontContent = (bodyMatch ? bodyMatch[1] : raw)
        // remove duplicate header/footer if your static has them
        .replace(/<\/?header[^>]*>[\s\S]*?<\/header>/gi, '')
        .replace(/<\/?footer[^>]*>[\s\S]*?<\/footer>/gi, '');
    }
    fs.writeFileSync(path.join(themeDir, 'front-page.php'), `<?php get_header(); ?>\n${frontContent}\n<?php get_footer(); ?>`);

    // --- Minimal ACF JSON for hero (users can expand later) ---
    fs.writeFileSync(path.join(acfJsonDir, 'home-hero.json'), JSON.stringify({
      key: 'group_home_hero',
      title: 'Home: Hero',
      fields: [
        { key: 'field_hero_h1', label: 'Hero H1', name: 'hero_h1', type: 'text' },
        { key: 'field_hero_tagline', label: 'Hero Tagline', name: 'hero_tagline', type: 'text' }
      ],
      location: [[{ param: 'page_type', operator: '==', value: 'front_page' }]],
      active: true
    }, null, 2));

    // --- Zip the theme ---
    const zipName = `${themeSlug}-theme.zip`;
    const zipPath = path.join(distDir, zipName);
    await new Promise((resolve, reject) => {
      const out = fs.createWriteStream(zipPath);
      const archive = archiver('zip', { zlib: { level: 9 } });
      out.on('close', resolve);
      archive.on('error', reject);
      archive.pipe(out);
      archive.directory(themeDir, false);
      archive.finalize();
    });

    // Response with download link (served from /dist)
    res.send(`
      <html><head>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
      </head><body><div class="container py-5">
        <h2>✅ WordPress theme generated from your static build</h2>
        <a class="btn btn-primary" href="/dist/${zipName}">Download Theme ZIP</a>
        <a class="btn btn-link mt-3" href="/">Back</a>
      </div></body></html>
    `);
  } catch (err) {
    console.error(err);
    res.status(500).send('Failed to export WordPress theme.');
  }
});

module.exports = router;
